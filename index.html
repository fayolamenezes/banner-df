<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebGL Banner Scroll Unroll</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/ScrollTrigger.min.js"></script>
<style>
  body { margin:0; background:#000; overflow-x:hidden; }
  canvas { display:block; }
</style>
</head>
<body>

<script>
let scene, camera, renderer, clock;
let rod, banner;

init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.localClippingEnabled = true;
    document.body.appendChild(renderer.domElement);

    // --- Rod ---
    const rodGeo = new THREE.BoxGeometry(window.innerWidth / window.innerHeight * 8, 0.05, 0.05);
    const rodMat = new THREE.MeshBasicMaterial({color: 0xffffff});
    rod = new THREE.Mesh(rodGeo, rodMat);
    rod.position.set(0, 4, 0);
    rod.scale.x = 0; 
    scene.add(rod);

    // --- Banner ---
    const bannerHeight = 4;
    const bannerWidth  = 10;
    const bannerGeo = new THREE.PlaneGeometry(bannerWidth, bannerHeight, 100, 50); 

    const clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 4);

    // ✅ High-resolution canvas for sharp text
    const textCanvas = document.createElement('canvas');
    textCanvas.width = 4096;   // double resolution
    textCanvas.height = 2048;
    const ctx = textCanvas.getContext('2d');
    ctx.imageSmoothingEnabled = false; // avoid extra blur

    // White background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, textCanvas.width, textCanvas.height);

    // --- Draw logo placeholders ---
    ctx.fillStyle = "#ccc";
    ctx.fillRect(1800, 200, 500, 260);  // Logo 1 top
    ctx.fillRect(1200, 600, 500, 260);  // Logo 2 left
    ctx.fillRect(2400, 600, 500, 260);  // Logo 3 right

    ctx.fillStyle = "#666";
    ctx.font = "bold 100px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("LOGO 1", 2050, 330);
    ctx.fillText("LOGO 2", 1450, 730);
    ctx.fillText("LOGO 3", 2650, 730);

    // --- Draw testimonial text with wrapping ---
    ctx.fillStyle = "#000000";
    ctx.font = "80px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    const quote = '"DOCTORFIZZ BRIDGES THE GAP BETWEEN POWERFUL SEO TOOLS AND EVERYDAY MARKETERS."';
    wrapText(ctx, quote, textCanvas.width/2, 1100, 3200, 100);

    ctx.font = "bold 90px Arial";
    ctx.fillText("— FOUNDER, SERPZILLA", textCanvas.width/2, 1400);

    // --- Texture from canvas ---
    const bannerTexture = new THREE.CanvasTexture(textCanvas);
    bannerTexture.needsUpdate = true;
    bannerTexture.minFilter = THREE.LinearFilter;
    bannerTexture.magFilter = THREE.NearestFilter;
    bannerTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const bannerMat = new THREE.MeshBasicMaterial({
        map: bannerTexture,
        side: THREE.DoubleSide,
        clippingPlanes: [clipPlane],
        toneMapped: false
    });

    banner = new THREE.Mesh(bannerGeo, bannerMat);
    banner.position.set(0, 4 + bannerHeight, 0);
    scene.add(banner);

    clock = new THREE.Clock();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        rod.geometry.dispose();
        rod.geometry = new THREE.BoxGeometry(window.innerWidth / window.innerHeight * 8, 0.05, 0.05);
    });

    document.body.style.height = `${window.innerHeight + bannerHeight*200}px`;

    gsap.registerPlugin(ScrollTrigger);

    const tl = gsap.timeline({
        scrollTrigger: {
            trigger: document.body,
            start: "top top",
            end: "+=" + bannerHeight*200,
            scrub: true,
            pin: true
        }
    });

    tl.to(rod.scale, { x: 1, ease: "power2.out" }, 0)
      .fromTo(banner.position, 
        { y: 4 + bannerHeight }, 
        { y: 4 - bannerHeight/2, ease: "power2.out" }, 
        0.5
      );
}

// ✅ Text wrapping helper
function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }
    ctx.fillText(line, x, y);
}

// --- Banner flutter ---
function updateBanner() {
    const time = clock.getElapsedTime();
    const geo = banner.geometry;
    const pos = geo.attributes.position;

    const h = geo.parameters.height;
    const w = geo.parameters.width;

    const gust = Math.sin(time * 1.5) * 0.3;

    for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);

        if (y >= h/2 - 0.01) {
            pos.setZ(i, 0);
            continue;
        }

        const distX = x / (w/2);
        const distY = y / (h/2);
        const dist = Math.sqrt(distX * distX + distY * distY);

        const bulge = gust * (1 - dist);

        const wave =
            Math.sin(x * 1.8 + time * 2.5) * 0.12 +
            Math.sin(y * 1.0 + time * 2.0) * 0.1 +
            Math.sin((x * 0.6 + y * 0.4) + time * 3.5) * 0.07;

        pos.setZ(i, bulge + wave);
    }

    pos.needsUpdate = true;
}

// --- Animation loop ---
function animate() {
    requestAnimationFrame(animate);
    updateBanner();
    renderer.render(scene, camera);
}
</script>

</body>
</html>
